---
name: pre-dev-dependency-map
description: |
  Gate 6: Technology choices document - explicit, versioned, validated technology
  selections with justifications. Large Track only. HARD BLOCK: Must load Ring Standards
  and PROJECT_RULES.md before proceeding.

trigger: |
  - Data Model passed Gate 5 validation
  - About to select specific technologies
  - Tempted to write "@latest" or "newest version"
  - Large Track workflow (2+ day features)

skip_when: |
  - Small Track workflow â†’ skip to Task Breakdown
  - Technologies already locked â†’ skip to Task Breakdown
  - Data Model not validated â†’ complete Gate 5 first

sequence:
  after: [pre-dev-data-model]
  before: [pre-dev-task-breakdown]
---

# Dependency Map - Explicit Technology Choices

## Foundational Principle

**Every technology choice must be explicit, versioned, validated against Ring Standards, and justified.**

Using vague or "latest" dependencies creates:
- Unreproducible builds across environments
- Hidden incompatibilities discovered during implementation
- Security vulnerabilities from unvetted versions
- Upgrade nightmares from undocumented constraints

**The Dependency Map answers**: WHAT specific products, versions, packages, and infrastructure we'll use.
**The Dependency Map never answers**: HOW to implement features (that's Tasks/Subtasks).

## When to Use This Skill

Use this skill when:
- Data Model has passed Gate 5 validation
- API Design has passed Gate 4 validation
- TRD has passed Gate 3 validation
- About to select specific technologies
- Tempted to write "@latest" or "newest version"
- Asked to finalize the tech stack
- Before breaking down implementation tasks

---

## â›” HARD BLOCK: Standards Loading (Step 0)

**This is a HARD GATE. Do NOT proceed without loading Ring Standards and TRD decisions.**

### Step 0.1: Read Technology Decisions from TRD (MANDATORY)

**The TRD (Gate 3) already analyzed the PRD and collected technology decisions. Read them:**

```text
Action: Read docs/pre-dev/{feature-name}/trd.md

Extract from TRD metadata:
- deployment.model (Cloud, On-Premise, Hybrid)
- tech_stack.primary (Go, TypeScript, etc.)
- project_technologies[] (all technology decisions from PRD analysis)
```

**If TRD metadata is missing:**

```yaml
Blocker:
  type: "missing_prerequisite"
  message: |
    â›” HARD BLOCK: TRD does not contain technology decisions.

    Gate 3 (TRD) should have:
    - Analyzed the PRD
    - Suggested technologies based on requirements
    - Collected user decisions in project_technologies[]

    Resolution:
    - Go back to TRD (Gate 3) and complete Step 0.4
    - Ensure TRD has project_technologies metadata
```

### Step 0.2: Load Ring Standards via WebFetch (MANDATORY)

**Load Ring Standards for coding patterns, observability, logging, etc.**

**Available Ring Standards:**

| Standard | URL | Purpose |
|----------|-----|---------|
| **golang.md** | `https://raw.githubusercontent.com/LerianStudio/ring/main/dev-team/docs/standards/golang.md` | Go coding patterns |
| **typescript.md** | `https://raw.githubusercontent.com/LerianStudio/ring/main/dev-team/docs/standards/typescript.md` | TypeScript coding patterns |
| **frontend.md** | `https://raw.githubusercontent.com/LerianStudio/ring/main/dev-team/docs/standards/frontend.md` | Frontend patterns |
| **devops.md** | `https://raw.githubusercontent.com/LerianStudio/ring/main/dev-team/docs/standards/devops.md` | DevOps patterns |
| **sre.md** | `https://raw.githubusercontent.com/LerianStudio/ring/main/dev-team/docs/standards/sre.md` | Observability, logging |

**Ring Standards vs PROJECT_RULES.md:**

| Ring Standards | PROJECT_RULES.md |
|----------------|------------------|
| Coding patterns | Specific technologies (Auth0, PostgreSQL, etc.) |
| Observability standards | Database versions |
| Logging format | Message broker choice |
| Error handling | Cloud/On-Premise configs |
| Shared across ALL projects | Specific to THIS project |

### Step 0.3: Generate PROJECT_RULES.md (OUTPUT)

**This skill CREATES `docs/PROJECT_RULES.md` from TRD technology decisions.**

Using the `project_technologies[]` from TRD, generate:

```markdown
# Project Rules - {project-name}

Generated by: pre-dev-dependency-map (Gate 6)
Based on: docs/pre-dev/{feature}/trd.md
Date: {date}

## Deployment Model

Model: {Cloud | On-Premise | Hybrid}

## Tech Stack

Primary Language: {Go | TypeScript}
Ring Standards Applied: {list}

## Project-Specific Technologies

These technologies were selected based on PRD requirements (analyzed in TRD Gate 3):

### {Category 1}
- **PRD Requirement:** "{quote from TRD}"
- **Technology:** {choice}
- **Version:** {specific version}
- **Rationale:** {why this fits}
- **Cloud Service:** {if cloud deployment}
- **On-Premise Alternative:** {if applicable}

### {Category 2}
...

## Version Matrix

| Component | Version | Rationale |
|-----------|---------|-----------|
| {tech 1} | {version} | {from TRD} |
| {tech 2} | {version} | {from TRD} |

## Security & Compliance

- {any security requirements from PRD}
```

### BLOCKER Response if Prerequisites Missing

```yaml
Blocker:
  type: "missing_prerequisite"
  message: |
    â›” HARD BLOCK: Cannot proceed with Dependency Map.

    REQUIRED:
    1. TRD technology decisions (project_technologies[]) âŒ
    2. Ring Standards loaded via WebFetch âŒ

    Resolution:
    - Verify TRD has project_technologies[] from PRD analysis
    - Retry WebFetch for Ring Standards
```

### Pressure Resistance for Step 0

| Pressure | Response |
|----------|----------|
| "TRD doesn't have technology decisions" | "Go back to TRD (Gate 3) and complete Step 0.4 (PRD analysis)." |
| "Ring Standards are optional" | "Ring Standards define coding patterns. PROJECT_RULES.md defines technologies. Both needed." |
| "Just use defaults" | "Defaults come from PRD analysis in TRD. Read TRD first." |
| "Skip to save time" | "PROJECT_RULES.md is the output. Cannot skip the output." |

---

## Mandatory Workflow

### Phase 1: Technology Evaluation (After Standards Loaded)
1. **Ring Standards loaded** (Step 0 passed) - organizational baseline available
2. **PROJECT_RULES.md loaded** (Step 0 passed) - project constraints available
3. **Approved Data Model** (Gate 5 passed) - data structures defined
4. **Approved API Design** (Gate 4 passed) - contracts specified
5. **Approved TRD** (Gate 3 passed) - architecture patterns locked
6. **Map each TRD component** to specific technology candidates
7. **Validate candidates** against Ring Standards mandatory/prohibited lists
8. **Map Data Model entities** to storage technologies
9. **Map API contracts** to protocol implementations
10. **Check team expertise** for proposed technologies
11. **Estimate costs** for infrastructure and services

### Phase 2: Stack Selection (Validated Against Standards)
For each technology choice:
1. **Check Ring Standards** - Is it mandatory? Is it prohibited?
2. **Check PROJECT_RULES.md** - Any project-specific overrides?
3. **Specify exact version** (not "latest", not range unless justified)
4. **List alternatives considered** with trade-offs
5. **Verify compatibility** with other dependencies
6. **Check security** for known vulnerabilities
7. **Validate licenses** for compliance
8. **Calculate costs** (infrastructure + services + support)

### Phase 3: Gate 6 Validation
**MANDATORY CHECKPOINT** - Must pass before proceeding to Task Breakdown:
- [ ] All dependencies have explicit versions
- [ ] No version conflicts exist
- [ ] No critical security vulnerabilities
- [ ] All licenses are compliant
- [ ] Team has expertise or learning path
- [ ] Costs are acceptable and documented
- [ ] Compatibility matrix verified
- [ ] All TRD components have dependencies mapped
- [ ] All API contracts have protocol implementations selected
- [ ] All Data Model entities have storage technologies selected

## Explicit Rules

### âœ… DO Include in Dependency Map
- Exact package names with explicit versions (go.uber.org/zap@v1.27.0)
- Technology stack with version constraints (Go 1.24+, PostgreSQL 16)
- Infrastructure services with specifications (Valkey 8, MinIO latest-stable)
- External service SDKs with versions
- Development tool requirements (Go 1.24+, Docker 24+)
- Security dependencies (crypto libraries, scanners)
- Monitoring/observability tools (specific products)
- Compatibility matrices (package A requires package B >= X)
- License summary for all dependencies
- Cost analysis (infrastructure + services)

### âŒ NEVER Include in Dependency Map
- Implementation code or examples
- How to use the dependencies
- Task breakdown or work units
- Step-by-step setup instructions (those go in subtasks)
- Architectural patterns (those were in TRD)
- Business requirements (those were in PRD)

### Version Specification Rules
1. **Explicit versions**: `@v1.27.0` not `@latest` or `^1.0.0`
2. **Justified ranges**: If using `>=`, document why (e.g., security patches)
3. **Lock file referenced**: `go.mod`, `package-lock.json`, etc.
4. **Upgrade constraints**: Document why version is locked/capped
5. **Compatibility**: Document known conflicts or requirements

## Rationalization Table

| Excuse | Reality |
|--------|---------|
| "Latest version is always best" | Latest is untested in your context. Pick specific, validate. |
| "I'll use flexible version ranges" | Ranges cause non-reproducible builds. Lock versions. |
| "Version numbers don't matter much" | They matter critically. Specify or face build failures. |
| "We can update versions later" | Document constraints now. Future you needs context. |
| "The team knows the stack already" | Document it anyway. Teams change, memories fade. |
| "Security scanning can happen in CI" | Security analysis must happen before committing. Do it now. |
| "We'll figure out costs in production" | Costs must be estimated before building. Calculate now. |
| "Compatibility issues will surface in tests" | Validate compatibility NOW. Don't wait for failures. |
| "License compliance is legal's problem" | You're responsible for your dependencies. Check licenses. |
| "I'll just use what the project template has" | Templates may be outdated/insecure. Validate explicitly. |

## Red Flags - STOP

If you catch yourself writing any of these in a Dependency Map, **STOP**:

- Version placeholders: `@latest`, `@next`, `^X.Y.Z` without justification
- Vague descriptions: "latest stable", "current version", "newest"
- Missing version numbers: Just package names without versions
- Unchecked compatibility: Not verifying version conflicts
- Unvetted security: Not checking vulnerability databases
- Unknown licenses: Not documenting license types
- Estimated costs as "TBD" or "unknown"
- "We'll use whatever is default" (no default without analysis)

**When you catch yourself**: Stop and specify the exact version after proper analysis.

## Gate 6 Validation Checklist

Before proceeding to Task Breakdown, verify:

**Standards Compliance (HARD BLOCK)**:
- [ ] Ring Standards loaded via WebFetch (Step 0.2 completed)
- [ ] PROJECT_RULES.md loaded (Step 0.3 completed)
- [ ] All mandatory dependencies from Ring Standards included (or justified)
- [ ] No prohibited choices from Ring Standards selected (or justified)
- [ ] All version constraints from Ring Standards respected (or justified)
- [ ] Deviations documented with explicit justification

**Compatibility**:
- [ ] All dependencies have explicit versions documented
- [ ] Version compatibility matrix is complete
- [ ] No known conflicts between dependencies
- [ ] Runtime requirements specified (OS, hardware)
- [ ] Upgrade path exists and is documented

**Security**:
- [ ] All dependencies scanned for vulnerabilities
- [ ] No critical (9.0+) or high (7.0-8.9) CVEs present
- [ ] Security update policy documented
- [ ] Supply chain verified (official sources only)

**Feasibility**:
- [ ] Team has expertise or documented learning path
- [ ] All tools are available/accessible
- [ ] Licensing allows commercial use
- [ ] Costs fit within budget

**Completeness**:
- [ ] Every TRD component has dependencies mapped
- [ ] Development environment fully specified
- [ ] CI/CD dependencies documented
- [ ] Monitoring/observability stack complete

**Documentation**:
- [ ] License summary created
- [ ] Cost analysis completed with estimates
- [ ] Known constraints documented
- [ ] Alternative technologies listed with rationale

**Gate Result**:
- âœ… **PASS**: All checkboxes checked (including Standards Compliance) â†’ Proceed to Tasks
- âš ï¸ **CONDITIONAL**: Standards not loaded OR deviations not justified â†’ Complete Step 0 first
- âŒ **FAIL**: Critical vulnerabilities, incompatibilities, OR standards not loaded â†’ Cannot proceed

## Common Violations and Fixes

### Violation 1: Vague Version Specifications
âŒ **Wrong**:
```yaml
Core Dependencies:
  - Fiber (latest)
  - PostgreSQL driver (current)
  - Zap (newest stable)
```

âœ… **Correct**:
```yaml
Core Dependencies:
  - gofiber/fiber/v2@v2.52.0
    Purpose: HTTP router and middleware
    Alternatives Considered: net/http (too low-level), gin (less active)
    Trade-offs: Accepting Express-like API for Go

  - lib/pq@v1.10.9
    Purpose: PostgreSQL driver
    Alternatives Considered: pgx (more complex than needed)
    Constraint: Must remain compatible with database/sql

  - go.uber.org/zap@v1.27.0
    Purpose: Structured logging
    Alternatives Considered: logrus (slower), slog (Go 1.21+ only)
    Trade-offs: Accepting Uber's opinionated API
```

### Violation 2: Missing Security Analysis
âŒ **Wrong**:
```yaml
JWT Library: golang-jwt/jwt@v5.0.0
```

âœ… **Correct**:
```yaml
JWT Library:
  Package: golang-jwt/jwt@v5.2.0
  Purpose: JWT token generation and validation
  Security:
    - CVE Check: Clean (no known vulnerabilities as of 2024-01-15)
    - OWASP: Follows best practices for token handling
    - Updates: Security patches applied within 24h historically
  Alternatives: cristalhq/jwt (no community), lestrrat-go/jwx (complex)
```

### Violation 3: Undefined Infrastructure
âŒ **Wrong**:
```yaml
Infrastructure:
  - Some database (probably Postgres)
  - Cache (Redis or Valkey)
  - Storage for files
```

âœ… **Correct**:
```yaml
Infrastructure:
  Database:
    Product: PostgreSQL 16.1
    Rationale: ACID guarantees, proven stability, team expertise
    Configuration: Single primary + 2 read replicas
    Cost: $450/month (managed service) or $120/month (self-hosted)

  Cache:
    Product: Valkey 8.0
    Rationale: Redis fork, OSS license, compatible APIs
    Configuration: 3-node cluster, 16GB RAM total
    Cost: $90/month (managed) or $45/month (self-hosted)

  Object Storage:
    Product: MinIO (latest stable release branch)
    Rationale: S3-compatible, self-hosted, no vendor lock
    Configuration: 4-node distributed setup, 4TB storage
    Cost: $200/month (infrastructure only)
```

## Dependency Resolution Patterns

### Standards-Driven Validation (MANDATORY)

**Step 0.1 Alternative: If Language Cannot Be Auto-Detected**

When project manifest files (go.mod, package.json) don't exist or are ambiguous, you MUST ask:

```yaml
AskUserQuestion:
  questions:
    - question: "What is the primary technology stack for this feature?"
      header: "Tech Stack"
      multiSelect: true
      options:
        - label: "Go (Backend)"
          description: "Load golang.md standards"
        - label: "TypeScript (Backend)"
          description: "Load typescript.md standards"
        - label: "TypeScript (Frontend)"
          description: "Load frontend.md standards"
        - label: "Full-Stack TypeScript"
          description: "Load typescript.md + frontend.md standards"
```

**After user selection, load the corresponding Ring Standards:**

| User Selection | Standards to Load via WebFetch |
|----------------|-------------------------------|
| Go (Backend) | golang.md + devops.md + sre.md |
| TypeScript (Backend) | typescript.md + devops.md + sre.md |
| TypeScript (Frontend) | frontend.md + devops.md |
| Full-Stack TypeScript | typescript.md + frontend.md + devops.md + sre.md |

### Validation Flow

**All technology choices MUST be validated against loaded standards:**

```yaml
Validation Flow:
  1. Standards Loaded (from user selection or auto-detection):
     â””â”€â”€ WebFetch completed for selected stack

  2. Extract from Ring Standards:
     â”œâ”€â”€ Mandatory dependencies â†’ List from loaded standards
     â”œâ”€â”€ Prohibited choices â†’ List from loaded standards
     â””â”€â”€ Version constraints â†’ List from loaded standards

  3. Check PROJECT_RULES.md:
     â”œâ”€â”€ Project-specific overrides â†’ Apply
     â”œâ”€â”€ Additional constraints â†’ Add
     â””â”€â”€ Exceptions â†’ Document with justification

  4. Validate Each Selection:
     â”œâ”€â”€ Against mandatory list â†’ Must include or justify
     â”œâ”€â”€ Against prohibited list â†’ Must not include or justify
     â””â”€â”€ Against version constraints â†’ Must comply or justify
```

**Validation Output Template:**

```yaml
Standards Compliance Check:
  User Selection: [Go/TypeScript/Frontend/Full-Stack]
  Ring Standards Loaded:
    - [language].md âœ…
    - devops.md âœ…
    - sre.md âœ…
  PROJECT_RULES.md: [path] âœ…

  Mandatory Dependencies (extracted from Ring Standards):
    # List dynamically from loaded standards
    # Check each against user's selections

  Prohibited Choices (extracted from Ring Standards):
    # List dynamically from loaded standards
    # Verify none are selected

  Version Constraints (extracted from Ring Standards):
    # List dynamically from loaded standards
    # Verify all selections comply

  Deviations (if any):
    # Document with user-provided justification
```

**Note:** The specific dependencies, prohibited choices, and version constraints come ENTIRELY from the Ring Standards loaded via WebFetch. This skill does NOT hardcode any technology-specific requirements.

### General Best Practices
```yaml
Prefer:
  - Semantic versioned packages (major.minor.patch)
  - Well-maintained packages (commits within 6 months)
  - Minimal dependency trees (avoid transitive bloat)
  - Standard library when sufficient

Avoid:
  - Deprecated packages (marked or unmaintained >1 year)
  - Single-maintainer critical dependencies
  - Packages with >100 transitive dependencies
  - GPL licenses unless compliance is certain
```

## License Compliance

Document all licenses:

```yaml
License Summary:
  MIT: 45 packages
    - Permissive, commercial use allowed
    - Attribution required in binary distributions

  Apache 2.0: 23 packages
    - Patent grant included
    - Attribution required

  BSD-3-Clause: 12 packages
    - Permissive, attribution required

  Commercial/Proprietary: 2 packages
    - cloud-vendor-sdk: Covered under service agreement
    - monitoring-agent: Free tier for <100 hosts

Compliance Actions:
  - [ ] Attribution file created for distributions
  - [ ] Legal team notified of commercial dependencies
  - [ ] GPL dependencies: None (verified âœ“)
```

## Cost Analysis Template

```yaml
Infrastructure Costs (Monthly):
  Compute:
    - Production: 4 containers Ã— $50 = $200
    - Staging: 2 containers Ã— $25 = $50
    - Total: $250/month

  Storage:
    - Database: $450 (managed PostgreSQL 16)
    - Cache: $90 (managed Valkey cluster)
    - Object: $200 (self-hosted MinIO on $50 VMs)
    - Total: $740/month

  Network:
    - Data transfer: ~$30/month (estimated)
    - Load balancer: $20/month
    - Total: $50/month

  Third-Party Services:
    - Auth provider: $100/month (10k MAU)
    - Email service: $50/month
    - Monitoring: $0 (self-hosted)
    - Total: $150/month

Grand Total: $1,190/month base
Scaling Cost: +$150 per 1000 additional users

Cost Validation:
  - Budget: $2,000/month available
  - Margin: 40% buffer for growth
  - Status: âœ… Within budget
```

## Confidence Scoring

Use this to adjust your interaction with the user:

```yaml
Confidence Factors:
  Technology Familiarity: [0-30]
    - Stack used successfully before: 30
    - Similar stack with variations: 20
    - Novel technology choices: 10

  Compatibility Verification: [0-25]
    - All dependencies verified compatible: 25
    - Most dependencies checked: 15
    - Limited verification: 5

  Security Assessment: [0-25]
    - Full CVE scan completed: 25
    - Basic security check done: 15
    - No security review: 5

  Cost Analysis: [0-20]
    - Detailed cost breakdown: 20
    - Rough estimates: 12
    - No cost analysis: 5

Total: [0-100]

Action:
  80+: Generate complete dependency map autonomously
  50-79: Present alternatives for key dependencies
  <50: Ask about team expertise and constraints
```

## Output Location

**Always output to**: `docs/pre-dev/{feature-name}/dependency-map.md`

## After Dependency Map Approval

1. âœ… Lock all versions - update only with documented justification
2. ðŸŽ¯ Create lock files (go.mod, package-lock.json, etc.)
3. ðŸ”’ Set up Dependabot or equivalent for security updates
4. ðŸ“‹ Proceed to task breakdown with full stack context

## Quality Self-Check

Before declaring Dependency Map complete, verify:

**Standards (HARD BLOCK - Check First)**:
- [ ] Ring Standards loaded via WebFetch for detected/selected tech stack
- [ ] PROJECT_RULES.md loaded and applied
- [ ] All selections validated against Ring Standards
- [ ] Deviations documented with justification

**Dependencies**:
- [ ] Every dependency has explicit version (no @latest)
- [ ] All version conflicts resolved and documented
- [ ] Security scan completed (CVE database checked)
- [ ] All licenses documented and compliant
- [ ] Cost analysis completed with monthly estimates
- [ ] Team expertise verified or learning plan exists
- [ ] Compatibility matrix complete
- [ ] Upgrade constraints documented
- [ ] All TRD components have dependencies mapped
- [ ] Gate 6 validation checklist 100% complete

## The Bottom Line

**If you skipped loading Ring Standards, STOP and go back to Step 0.**

**If you wrote a Dependency Map without explicit versions, add them now or start over.**

Two non-negotiable requirements:
1. **Ring Standards MUST be loaded** - Technology choices validated against organizational baseline
2. **Every dependency MUST be explicit** - No @latest, no vague versions, no "we'll figure it out"

Skipping standards causes:
- Non-compliant technology choices discovered during review
- Rework when mandatory dependencies are missing
- Security issues from prohibited choices
- Inconsistency across projects

Vague dependencies cause:
- Non-reproducible builds that work on your machine but fail elsewhere
- Security vulnerabilities from unvetted versions
- Incompatibilities discovered during implementation (too late)
- Impossible debugging when "it worked yesterday"

**Load standards first. Be explicit. Be specific. Lock your versions.**

Your deployment engineer will thank you. Your future debugging self will thank you. Your security team will thank you.
